defmodule BABE.ParticipantSocket do
  use Phoenix.Socket
  require Ecto.Query
  alias BABE.{Repo, Experiment, ExperimentResult, ExperimentStatus}
  alias Ecto.Multi

  ## Channels
  # channel "room:*", BABE.RoomChannel

  # Participant Channel is responsible for holding 2-to-1 connections with each participant.
  # The ":*" part just means that any event with `participant` topic will be sent to the Participant channel.
  channel("participant:*", BABE.ParticipantChannel)
  channel("interactive_experiment:*", BABE.InteractiveExperimentChannel)
  channel("lobby:*", BABE.LobbyChannel)

  ## Transports
  transport(:websocket, Phoenix.Transports.WebSocket,
    # Ensures idle connections are closed by the app before the 55 second timeout window of Heroku.
    timeout: 45_000
  )

  # transport :longpoll, Phoenix.Transports.LongPoll

  # Socket params are passed from the client and can
  # be used to verify and authenticate a participant. After
  # verification, you can put default assigns into
  # the socket that will be set for all channels, ie
  #
  #     {:ok, assign(socket, :participant_id, verified_participant_id)}
  #
  # To deny connection, return `:error`.
  #
  # See `Phoenix.Token` documentation for examples in
  # performing token verification on connect.

  # def connect(_params, socket) do
  #   {:ok, socket}
  # end

  # The "participant_id" is just a string randomly generated by the frontend to uniquely identify the participant. We don't have registration mechanisms for the participants for now.
  # The second item to return is the socket. We need to add assigns to the socket before returning it.
  def connect(%{"participant_id" => participant_id, "experiment_id" => experiment_id}, socket) do
    # Well I can perform the check on the experiment here or I can perform the check when the user tries to subscribe to the particular participant topic.
    # Though indeed maybe why even open the socket connection at all if the experiment id is invalid in the first place. Let's see.
    experiment = Repo.get(Experiment, experiment_id)

    case experiment do
      nil ->
        {:error, %{reason: "The experiment with the given id doesn't exist."}}

      _ ->
        if !experiment.active do
          {:error, %{reason: "The experiment is not active."}}
        else
          # OK this will likely be a bit slow but I hope the speed will still be efficient enough. The participant can wait.
          available_assignments_query =
            Ecto.Query.from(s in ExperimentStatus,
              where: s.experiment_id == ^experiment_id,
              where: s.status == 0,
              order_by: [s.variant, s.chain, s.realization]
              # limit: 1
            )

          available_assignments = Repo.all(available_assignments_query)

          case available_assignments do
            [] ->
              # All experiment slots are full.
              {:error, %{reason: "no_available_assignment"}}

            # Mark this assignment as "in progress", i.e. allocated to this participant.
            # The participant should then go into some sort of waiting lobby and check if the data from the predecessor is already available.
            # The query does not necessarily have to be answered from the channel, though a key use case is to end the wait whenever the result becomes available
            # Yeah I get it. We should try to push out the message whenever the previous result comes in.
            # Of course this doesn't actually ensure the result was valid. Guess the frontend will have to do something about that.
            [next_assignment | _] ->
              changeset =
                next_assignment
                |> ExperimentStatus.changeset(%{status: 1})

              case Repo.update(changeset) do
                {:ok, _} ->
                  {:ok,
                   socket
                   |> assign(:participant_id, participant_id)
                   |> assign(:experiment_id, experiment_id)
                   |> assign(:variant, next_assignment.variant)
                   |> assign(:chain, next_assignment.chain)
                   |> assign(:realization, next_assignment.realization)}

                {:error, _changeset} ->
                  {:error, %{reason: "db_error"}}
              end
          end
        end
    end
  end

  # The incoming payload doesn't have the participant_id and experiment_id fields. Reject connection.
  def connect(_params, _socket), do: :error

  # Socket id's are topics that allow you to identify all sockets for a given participant:
  #
  #     def id(socket), do: "participants_socket:#{socket.assigns.participant_id}"
  #
  # Would allow you to broadcast a "disconnect" event and terminate
  # all active sockets and channels for a given participant:
  #
  #     BABE.Endpoint.broadcast("participants_socket:#{participant.id}", "disconnect", %{})
  #
  # Returning `nil` makes this socket anonymous.
  def id(_socket), do: nil
end
